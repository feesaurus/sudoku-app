{"ast":null,"code":"/*\r\n    Sudoku.js\r\n    ---------\r\n\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n\r\n    Please see the README for more details.\r\n*/ //(function(root){\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\nvar sudoku={};sudoku.DIGITS=\"123456789\";// Allowed sudoku.DIGITS\nvar ROWS=\"ABCDEFGHI\";// Row lables\nvar COLS=sudoku.DIGITS;// Column lables\nvar SQUARES=null;// Square IDs\nvar UNITS=null;// All units (row, column, or box)\nvar SQUARE_UNITS_MAP=null;// Squares -> units map\nvar SQUARE_PEERS_MAP=null;// Squares -> peers map\nvar MIN_GIVENS=17;// Minimum number of givens\nvar NR_SQUARES=81;// Number of squares\n// Define difficulties by how many squares are given to the player in a new\n// puzzle.\nvar DIFFICULTY={\"easy\":62,\"medium\":53,\"hard\":44,\"very-hard\":35,\"insane\":26,\"inhuman\":17};// Blank character and board representation\nsudoku.BLANK_CHAR='.';sudoku.BLANK_BOARD=\"....................................................\"+\".............................\";// Init\n// -------------------------------------------------------------------------\nfunction initialize(){/* Initialize the Sudoku library (invoked after library load)\r\n  */SQUARES=sudoku._cross(ROWS,COLS);UNITS=sudoku._get_all_units(ROWS,COLS);SQUARE_UNITS_MAP=sudoku._get_square_units_map(SQUARES,UNITS);SQUARE_PEERS_MAP=sudoku._get_square_peers_map(SQUARES,SQUARE_UNITS_MAP);}// Generate\n// -------------------------------------------------------------------------\nsudoku.generate=function(difficulty,unique){/* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n\r\n      // Generate an \"easy\" sudoku puzzle\r\n      sudoku.generate(\"easy\");\r\n\r\n\r\n  Difficulties are as follows, and represent the number of given squares:\r\n\r\n          \"easy\":         61\r\n          \"medium\":       52\r\n          \"hard\":         43\r\n          \"very-hard\":    34\r\n          \"insane\":       25\r\n          \"inhuman\":      17\r\n\r\n\r\n  You may also enter a custom number of squares to be given, e.g.,\r\n\r\n      // Generate a new Sudoku puzzle with 60 given squares\r\n      sudoku.generate(60)\r\n\r\n\r\n  `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n  outside of that range, `difficulty` will be set to the closest bound,\r\n  e.g., 0 -> 17, and 100 -> 81.\r\n\r\n\r\n  By default, the puzzles are unique, uless you set `unique` to false.\r\n  (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\r\n  guaranteed to have unique solutions)\r\n\r\n  TODO: Implement puzzle uniqueness\r\n  */ // If `difficulty` is a string or undefined, convert it to a number or\n// default it to \"easy\" if undefined.\nif(typeof difficulty===\"string\"||typeof difficulty===\"undefined\"){difficulty=DIFFICULTY[difficulty]||DIFFICULTY.easy;}// Force difficulty between 17 and 81 inclusive\ndifficulty=sudoku._force_range(difficulty,NR_SQUARES+1,MIN_GIVENS);// Default unique to true\nunique=unique||true;// Get a set of squares and all possible candidates for each square\nvar blank_board=\"\";for(var i=0;i<NR_SQUARES;++i){blank_board+='.';}var candidates=sudoku._get_candidates_map(blank_board);// For each item in a shuffled list of squares\nvar shuffled_squares=sudoku._shuffle(SQUARES);for(var si in shuffled_squares){var square=shuffled_squares[si];// If an assignment of a random chioce causes a contradictoin, give\n// up and try again\nvar rand_candidate_idx=sudoku._rand_range(candidates[square].length);var rand_candidate=candidates[square][rand_candidate_idx];if(!sudoku._assign(candidates,square,rand_candidate)){break;}// Make a list of all single candidates\nvar single_candidates=[];for(si in SQUARES){square=SQUARES[si];if(candidates[square].length===1){single_candidates.push(candidates[square]);}}// If we have at least difficulty, and the unique candidate count is\n// at least 8, return the puzzle!\nif(single_candidates.length>=difficulty&&sudoku._strip_dups(single_candidates).length>=8){var board=\"\";var givens_idxs=[];for(i in SQUARES){square=SQUARES[i];if(candidates[square].length===1){board+=candidates[square];givens_idxs.push(i);}else{board+=sudoku.BLANK_CHAR;}}// If we have more than `difficulty` givens, remove some random\n// givens until we're down to exactly `difficulty`\nvar nr_givens=givens_idxs.length;if(nr_givens>difficulty){givens_idxs=sudoku._shuffle(givens_idxs);for(i=0;i<nr_givens-difficulty;++i){var target=parseInt(givens_idxs[i]);board=board.substr(0,target)+sudoku.BLANK_CHAR+board.substr(target+1);}}// Double check board is solvable\n// TODO: Make a standalone board checker. Solve is expensive.\nif(sudoku.solve(board)){return board;}}}// Give up and try a new puzzle\nreturn sudoku.generate(difficulty);};// Solve\n// -------------------------------------------------------------------------\nsudoku.solve=function(board,reverse){/* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\r\n  string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n  squares. There must be a minimum of 17 givens. If the given board has no\r\n  solutions, return false.\r\n\r\n  Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n  possibilities in reverse. Useful for checking if there is more than one\r\n  solution.\r\n  */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}// Check number of givens is at least MIN_GIVENS\nvar nr_givens=0;for(var i in board){if(board[i]!==sudoku.BLANK_CHAR&&sudoku._in(board[i],sudoku.DIGITS)){++nr_givens;}}if(nr_givens<MIN_GIVENS){// eslint-disable-next-line\nthrow\"Too few givens. Minimum givens is \"+MIN_GIVENS;}// Default reverse to false\nreverse=reverse||false;var candidates=sudoku._get_candidates_map(board);var result=sudoku._search(candidates,reverse);if(result){var solution=\"\";for(var square in result){solution+=result[square];}return solution;}return false;};sudoku.get_candidates=function(board){/* Return all possible candidatees for each square as a grid of\r\n  candidates, returnning `false` if a contradiction is encountered.\r\n\r\n  Really just a wrapper for sudoku._get_candidates_map for programmer\r\n  consumption.\r\n  */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}// Get a candidates map\nvar candidates_map=sudoku._get_candidates_map(board);// If there's an error, return false\nif(!candidates_map){return false;}// Transform candidates map into grid\nvar rows=[];var cur_row=[];var i=0;for(var square in candidates_map){var candidates=candidates_map[square];cur_row.push(candidates);if(i%9===8){rows.push(cur_row);cur_row=[];}++i;}return rows;};sudoku._get_candidates_map=function(board){/* Get all possible candidates for each square as a map in the form\r\n  {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\r\n  if a contradiction is encountered\r\n  */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}var candidate_map={};var squares_values_map=sudoku._get_square_vals_map(board);// Start by assigning every digit as a candidate to every square\nfor(var si in SQUARES){candidate_map[SQUARES[si]]=sudoku.DIGITS;}// For each non-blank square, assign its value in the candidate map and\n// propigate.\nfor(var square in squares_values_map){var val=squares_values_map[square];if(sudoku._in(val,sudoku.DIGITS)){var new_candidates=sudoku._assign(candidate_map,square,val);// Fail if we can't assign val to square\nif(!new_candidates){return false;}}}return candidate_map;};sudoku._search=function(candidates,reverse){/* Given a map of squares -> candiates, using depth-first search,\r\n  recursively try all possible values until a solution is found, or false\r\n  if no solution exists.\r\n  */ // Return if error in previous iteration\nif(!candidates){return false;}// Default reverse to false\nreverse=reverse||false;// If only one candidate for every square, we've a solved puzzle!\n// Return the candidates map.\nvar max_nr_candidates=0;// eslint-disable-next-line\nvar max_candidates_square=null;for(var si in SQUARES){var square=SQUARES[si];var nr_candidates=candidates[square].length;if(nr_candidates>max_nr_candidates){max_nr_candidates=nr_candidates;// eslint-disable-next-line no-unused-vars\nmax_candidates_square=square;}}if(max_nr_candidates===1){return candidates;}// Choose the blank square with the fewest possibilities > 1\nvar min_nr_candidates=10;var min_candidates_square=null;for(si in SQUARES){square=SQUARES[si];nr_candidates=candidates[square].length;if(nr_candidates<min_nr_candidates&&nr_candidates>1){min_nr_candidates=nr_candidates;min_candidates_square=square;}}// Recursively search through each of the candidates of the square\n// starting with the one with fewest candidates.\n// Rotate through the candidates forwards\nvar min_candidates=candidates[min_candidates_square];if(!reverse){for(var vi in min_candidates){var val=min_candidates[vi];// TODO: Implement a non-rediculous deep copy function\nvar candidates_copy=JSON.parse(JSON.stringify(candidates));var candidates_next=sudoku._search(sudoku._assign(candidates_copy,min_candidates_square,val));if(candidates_next){return candidates_next;}}// Rotate through the candidates backwards\n}else{for(vi=min_candidates.length-1;vi>=0;--vi){val=min_candidates[vi];// TODO: Implement a non-rediculous deep copy function\ncandidates_copy=JSON.parse(JSON.stringify(candidates));candidates_next=sudoku._search(sudoku._assign(candidates_copy,min_candidates_square,val),reverse);if(candidates_next){return candidates_next;}}}// If we get through all combinations of the square with the fewest\n// candidates without finding an answer, there isn't one. Return false.\nreturn false;};sudoku._assign=function(candidates,square,val){/* Eliminate all values, *except* for `val`, from `candidates` at\r\n  `square` (candidates[square]), and propagate. Return the candidates map\r\n  when finished. If a contradiciton is found, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */ // Grab a list of canidates without 'val'\nvar other_vals=candidates[square].replace(val,\"\");// Loop through all other values and eliminate them from the candidates\n// at the current square, and propigate. If at any point we get a\n// contradiction, return false.\nfor(var ovi in other_vals){var other_val=other_vals[ovi];var candidates_next=sudoku._eliminate(candidates,square,other_val);if(!candidates_next){//console.log(\"Contradiction found by _eliminate.\");\nreturn false;}}return candidates;};sudoku._eliminate=function(candidates,square,val){/* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n  and propagate when values or places <= 2. Return updated candidates,\r\n  unless a contradiction is detected, in which case, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */ // If `val` has already been eliminated from candidates[square], return\n// with candidates.\nif(!sudoku._in(val,candidates[square])){return candidates;}// Remove `val` from candidates[square]\ncandidates[square]=candidates[square].replace(val,'');// If the square has only candidate left, eliminate that value from its\n// peers\nvar nr_candidates=candidates[square].length;if(nr_candidates===1){var target_val=candidates[square];for(var pi in SQUARE_PEERS_MAP[square]){var peer=SQUARE_PEERS_MAP[square][pi];var candidates_new=sudoku._eliminate(candidates,peer,target_val);if(!candidates_new){return false;}}// Otherwise, if the square has no candidates, we have a contradiction.\n// Return false.\n}if(nr_candidates===0){return false;}// If a unit is reduced to only one place for a value, then assign it\nfor(var ui in SQUARE_UNITS_MAP[square]){var unit=SQUARE_UNITS_MAP[square][ui];var val_places=[];for(var si in unit){var unit_square=unit[si];if(sudoku._in(val,candidates[unit_square])){val_places.push(unit_square);}}// If there's no place for this value, we have a contradition!\n// return false\nif(val_places.length===0){return false;// Otherwise the value can only be in one place. Assign it there.\n}else if(val_places.length===1){candidates_new=sudoku._assign(candidates,val_places[0],val);if(!candidates_new){return false;}}}return candidates;};// Square relationships\n// -------------------------------------------------------------------------\n// Squares, and their relationships with values, units, and peers.\nsudoku._get_square_vals_map=function(board){/* Return a map of squares -> values\r\n  */var squares_vals_map={};// Make sure `board` is a string of length 81\nif(board.length!==SQUARES.length){// eslint-disable-next-line\nthrow\"Board/squares length mismatch.\";}else{for(var i in SQUARES){squares_vals_map[SQUARES[i]]=board[i];}}return squares_vals_map;};sudoku._get_square_units_map=function(squares,units){/* Return a map of `squares` and their associated units (row, col, box)\r\n  */var square_unit_map={};// For every square...\nfor(var si in squares){var cur_square=squares[si];// Maintain a list of the current square's units\nvar cur_square_units=[];// Look through the units, and see if the current square is in it,\n// and if so, add it to the list of of the square's units.\nfor(var ui in units){var cur_unit=units[ui];if(cur_unit.indexOf(cur_square)!==-1){cur_square_units.push(cur_unit);}}// Save the current square and its units to the map\nsquare_unit_map[cur_square]=cur_square_units;}return square_unit_map;};sudoku._get_square_peers_map=function(squares,units_map){/* Return a map of `squares` and their associated peers, i.e., a set of\r\n  other squares in the square's unit.\r\n  */var square_peers_map={};// For every square...\nfor(var si in squares){var cur_square=squares[si];var cur_square_units=units_map[cur_square];// Maintain list of the current square's peers\nvar cur_square_peers=[];// Look through the current square's units map...\nfor(var sui in cur_square_units){var cur_unit=cur_square_units[sui];for(var ui in cur_unit){var cur_unit_square=cur_unit[ui];if(cur_square_peers.indexOf(cur_unit_square)===-1&&cur_unit_square!==cur_square){cur_square_peers.push(cur_unit_square);}}}// Save the current square an its associated peers to the map\nsquare_peers_map[cur_square]=cur_square_peers;}return square_peers_map;};sudoku._get_all_units=function(rows,cols){/* Return a list of all units (rows, cols, boxes)\r\n  */var units=[];// Rows\nfor(var ri in rows){units.push(sudoku._cross(rows[ri],cols));}// Columns\nfor(var ci in cols){units.push(sudoku._cross(rows,cols[ci]));}// Boxes\nvar row_squares=[\"ABC\",\"DEF\",\"GHI\"];var col_squares=[\"123\",\"456\",\"789\"];for(var rsi in row_squares){for(var csi in col_squares){units.push(sudoku._cross(row_squares[rsi],col_squares[csi]));}}return units;};// Conversions\n// -------------------------------------------------------------------------\nsudoku.board_string_to_grid=function(board_string){/* Convert a board string to a two-dimensional array\r\n  */var rows=[];var cur_row=[];for(var i in board_string){cur_row.push(board_string[i]);if(i%9===8){rows.push(cur_row);cur_row=[];}}return rows;};sudoku.board_grid_to_string=function(board_grid){/* Convert a board grid to a string\r\n  */var board_string=\"\";for(var r=0;r<9;++r){for(var c=0;c<9;++c){board_string+=board_grid[r][c];}}return board_string;};// Utility\n// -------------------------------------------------------------------------\nsudoku.print_board=function(board){/* Print a sudoku `board` to the console.\r\n  */ // Assure a valid board\nvar report=sudoku.validate_board(board);if(report!==true){throw report;}var V_PADDING=\" \";// Insert after each square\nvar H_PADDING='\\n';// Insert after each row\nvar V_BOX_PADDING=\"  \";// Box vertical padding\nvar H_BOX_PADDING='\\n';// Box horizontal padding\nvar display_string=\"\";for(var i in board){var square=board[i];// Add the square and some padding\ndisplay_string+=square+V_PADDING;// Vertical edge of a box, insert v. box padding\nif(i%3===2){display_string+=V_BOX_PADDING;}// End of a line, insert horiz. padding\nif(i%9===8){display_string+=H_PADDING;}// Horizontal edge of a box, insert h. box padding\nif(i%27===26){display_string+=H_BOX_PADDING;}}console.log(display_string);};sudoku.validate_board=function(board){/* Return if the given `board` is valid or not. If it's valid, return\r\n  true. If it's not, return a string of the reason why it's not.\r\n  */ // Check for empty board\nif(!board){return\"Empty board\";}// Invalid board length\nif(board.length!==NR_SQUARES){return\"Invalid board size. Board must be exactly \"+NR_SQUARES+\" squares.\";}// Check for invalid characters\nfor(var i in board){if(!sudoku._in(board[i],sudoku.DIGITS)&&board[i]!==sudoku.BLANK_CHAR){return\"Invalid board character encountered at index \"+i+\": \"+board[i];}}// Otherwise, we're good. Return true.\nreturn true;};sudoku._cross=function(a,b){/* Cross product of all elements in `a` and `b`, e.g.,\r\n  sudoku._cross(\"abc\", \"123\") ->\r\n  [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n  */var result=[];for(var ai in a){for(var bi in b){result.push(a[ai]+b[bi]);}}return result;};sudoku._in=function(v,seq){/* Return if a value `v` is in sequence `seq`.\r\n  */return seq.indexOf(v)!==-1;};sudoku._first_true=function(seq){/* Return the first element in `seq` that is true. If no element is\r\n  true, return false.\r\n  */for(var i in seq){if(seq[i]){return seq[i];}}return false;};sudoku._shuffle=function(seq){/* Return a shuffled version of `seq`\r\n  */ // Create an array of the same size as `seq` filled with false\nvar shuffled=[];for(var i=0;i<seq.length;++i){shuffled.push(false);}for(i in seq){var ti=sudoku._rand_range(seq.length);while(shuffled[ti]){ti=ti+1>seq.length-1?0:ti+1;}shuffled[ti]=seq[i];}return shuffled;};sudoku._rand_range=function(max,min){/* Get a random integer in the range of `min` to `max` (non inclusive).\r\n  If `min` not defined, default to 0. If `max` not defined, throw an\r\n  error.\r\n  */min=min||0;if(max){return Math.floor(Math.random()*(max-min))+min;}else{// eslint-disable-next-line\nthrow\"Range undefined\";}};sudoku._strip_dups=function(seq){/* Strip duplicate values from `seq`\r\n  */var seq_set=[];var dup_map={};for(var i in seq){var e=seq[i];if(!dup_map[e]){seq_set.push(e);dup_map[e]=true;}}return seq_set;};sudoku._force_range=function(nr,max,min){/* Force `nr` to be within the range from `min` to, but not including,\r\n  `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n  treat it as zero.\r\n  */min=min||0;nr=nr||0;if(nr<min){return min;}if(nr>max){return max;}return nr;};// Initialize library after load\ninitialize();export var getSudoku=function getSudoku(){return sudoku;};// Pass whatever the root object is, like 'window' in browsers\n//})(this);","map":{"version":3,"names":["sudoku","DIGITS","ROWS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","DIFFICULTY","BLANK_CHAR","BLANK_BOARD","initialize","_cross","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","easy","_force_range","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","new_candidates","max_nr_candidates","max_candidates_square","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","candidates_new","ui","unit","val_places","unit_square","squares_vals_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","cols","ri","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr","getSudoku"],"sources":["C:/Users/NEXSOFT/Documents/.practice/sudoku-app/src/solver/sudoku.js"],"sourcesContent":["/*\r\n    Sudoku.js\r\n    ---------\r\n\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n\r\n    Please see the README for more details.\r\n*/\r\n\r\n//(function(root){\r\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\r\nvar sudoku = {};\r\nsudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\r\nvar ROWS = \"ABCDEFGHI\";         // Row lables\r\nvar COLS = sudoku.DIGITS;       // Column lables\r\nvar SQUARES = null;             // Square IDs\r\n\r\nvar UNITS = null;               // All units (row, column, or box)\r\nvar SQUARE_UNITS_MAP = null;    // Squares -> units map\r\nvar SQUARE_PEERS_MAP = null;    // Squares -> peers map\r\n\r\nvar MIN_GIVENS = 17;            // Minimum number of givens\r\nvar NR_SQUARES = 81;            // Number of squares\r\n\r\n// Define difficulties by how many squares are given to the player in a new\r\n// puzzle.\r\nvar DIFFICULTY = {\r\n  \"easy\": 62,\r\n  \"medium\": 53,\r\n  \"hard\": 44,\r\n  \"very-hard\": 35,\r\n  \"insane\": 26,\r\n  \"inhuman\": 17,\r\n};\r\n\r\n// Blank character and board representation\r\nsudoku.BLANK_CHAR = '.';\r\nsudoku.BLANK_BOARD = \"....................................................\" +\r\n  \".............................\";\r\n\r\n// Init\r\n// -------------------------------------------------------------------------\r\nfunction initialize() {\r\n  /* Initialize the Sudoku library (invoked after library load)\r\n  */\r\n  SQUARES = sudoku._cross(ROWS, COLS);\r\n  UNITS = sudoku._get_all_units(ROWS, COLS);\r\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS);\r\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES,\r\n    SQUARE_UNITS_MAP);\r\n}\r\n\r\n// Generate\r\n// -------------------------------------------------------------------------\r\nsudoku.generate = function (difficulty, unique) {\r\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n\r\n      // Generate an \"easy\" sudoku puzzle\r\n      sudoku.generate(\"easy\");\r\n\r\n\r\n  Difficulties are as follows, and represent the number of given squares:\r\n\r\n          \"easy\":         61\r\n          \"medium\":       52\r\n          \"hard\":         43\r\n          \"very-hard\":    34\r\n          \"insane\":       25\r\n          \"inhuman\":      17\r\n\r\n\r\n  You may also enter a custom number of squares to be given, e.g.,\r\n\r\n      // Generate a new Sudoku puzzle with 60 given squares\r\n      sudoku.generate(60)\r\n\r\n\r\n  `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n  outside of that range, `difficulty` will be set to the closest bound,\r\n  e.g., 0 -> 17, and 100 -> 81.\r\n\r\n\r\n  By default, the puzzles are unique, uless you set `unique` to false.\r\n  (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\r\n  guaranteed to have unique solutions)\r\n\r\n  TODO: Implement puzzle uniqueness\r\n  */\r\n\r\n  // If `difficulty` is a string or undefined, convert it to a number or\r\n  // default it to \"easy\" if undefined.\r\n  if (typeof difficulty === \"string\" || typeof difficulty === \"undefined\") {\r\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\r\n  }\r\n\r\n  // Force difficulty between 17 and 81 inclusive\r\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1,\r\n    MIN_GIVENS);\r\n\r\n  // Default unique to true\r\n  unique = unique || true;\r\n\r\n  // Get a set of squares and all possible candidates for each square\r\n  var blank_board = \"\";\r\n  for (var i = 0; i < NR_SQUARES; ++i) {\r\n    blank_board += '.';\r\n  }\r\n  var candidates = sudoku._get_candidates_map(blank_board);\r\n\r\n  // For each item in a shuffled list of squares\r\n  var shuffled_squares = sudoku._shuffle(SQUARES);\r\n  for (var si in shuffled_squares) {\r\n    var square = shuffled_squares[si];\r\n\r\n    // If an assignment of a random chioce causes a contradictoin, give\r\n    // up and try again\r\n    var rand_candidate_idx =\r\n      sudoku._rand_range(candidates[square].length);\r\n    var rand_candidate = candidates[square][rand_candidate_idx];\r\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\r\n      break;\r\n    }\r\n\r\n    // Make a list of all single candidates\r\n    var single_candidates = [];\r\n    for (si in SQUARES) {\r\n      square = SQUARES[si];\r\n\r\n      if (candidates[square].length === 1) {\r\n        single_candidates.push(candidates[square]);\r\n      }\r\n    }\r\n\r\n    // If we have at least difficulty, and the unique candidate count is\r\n    // at least 8, return the puzzle!\r\n    if (single_candidates.length >= difficulty &&\r\n      sudoku._strip_dups(single_candidates).length >= 8) {\r\n      var board = \"\";\r\n      var givens_idxs = [];\r\n      for (i in SQUARES) {\r\n        square = SQUARES[i];\r\n        if (candidates[square].length === 1) {\r\n          board += candidates[square];\r\n          givens_idxs.push(i);\r\n        } else {\r\n          board += sudoku.BLANK_CHAR;\r\n        }\r\n      }\r\n\r\n      // If we have more than `difficulty` givens, remove some random\r\n      // givens until we're down to exactly `difficulty`\r\n      var nr_givens = givens_idxs.length;\r\n      if (nr_givens > difficulty) {\r\n        givens_idxs = sudoku._shuffle(givens_idxs);\r\n        for (i = 0; i < nr_givens - difficulty; ++i) {\r\n          var target = parseInt(givens_idxs[i]);\r\n          board = board.substr(0, target) + sudoku.BLANK_CHAR +\r\n            board.substr(target + 1);\r\n        }\r\n      }\r\n\r\n      // Double check board is solvable\r\n      // TODO: Make a standalone board checker. Solve is expensive.\r\n      if (sudoku.solve(board)) {\r\n        return board;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Give up and try a new puzzle\r\n  return sudoku.generate(difficulty);\r\n};\r\n\r\n// Solve\r\n// -------------------------------------------------------------------------\r\nsudoku.solve = function (board, reverse) {\r\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\r\n  string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n  squares. There must be a minimum of 17 givens. If the given board has no\r\n  solutions, return false.\r\n\r\n  Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n  possibilities in reverse. Useful for checking if there is more than one\r\n  solution.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  // Check number of givens is at least MIN_GIVENS\r\n  var nr_givens = 0;\r\n  for (var i in board) {\r\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\r\n      ++nr_givens;\r\n    }\r\n  }\r\n  if (nr_givens < MIN_GIVENS) {\r\n    // eslint-disable-next-line\r\n    throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false;\r\n\r\n  var candidates = sudoku._get_candidates_map(board);\r\n  var result = sudoku._search(candidates, reverse);\r\n\r\n  if (result) {\r\n    var solution = \"\";\r\n    for (var square in result) {\r\n      solution += result[square];\r\n    }\r\n    return solution;\r\n  }\r\n  return false;\r\n};\r\n\r\nsudoku.get_candidates = function (board) {\r\n  /* Return all possible candidatees for each square as a grid of\r\n  candidates, returnning `false` if a contradiction is encountered.\r\n\r\n  Really just a wrapper for sudoku._get_candidates_map for programmer\r\n  consumption.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  // Get a candidates map\r\n  var candidates_map = sudoku._get_candidates_map(board);\r\n\r\n  // If there's an error, return false\r\n  if (!candidates_map) {\r\n    return false;\r\n  }\r\n\r\n  // Transform candidates map into grid\r\n  var rows = [];\r\n  var cur_row = [];\r\n  var i = 0;\r\n  for (var square in candidates_map) {\r\n    var candidates = candidates_map[square];\r\n    cur_row.push(candidates);\r\n    if (i % 9 === 8) {\r\n      rows.push(cur_row);\r\n      cur_row = [];\r\n    }\r\n    ++i;\r\n  }\r\n  return rows;\r\n}\r\n\r\nsudoku._get_candidates_map = function (board) {\r\n  /* Get all possible candidates for each square as a map in the form\r\n  {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\r\n  if a contradiction is encountered\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  var candidate_map = {};\r\n  var squares_values_map = sudoku._get_square_vals_map(board);\r\n\r\n  // Start by assigning every digit as a candidate to every square\r\n  for (var si in SQUARES) {\r\n    candidate_map[SQUARES[si]] = sudoku.DIGITS;\r\n  }\r\n\r\n  // For each non-blank square, assign its value in the candidate map and\r\n  // propigate.\r\n  for (var square in squares_values_map) {\r\n    var val = squares_values_map[square];\r\n\r\n    if (sudoku._in(val, sudoku.DIGITS)) {\r\n      var new_candidates = sudoku._assign(candidate_map, square, val);\r\n\r\n      // Fail if we can't assign val to square\r\n      if (!new_candidates) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidate_map;\r\n};\r\n\r\nsudoku._search = function (candidates, reverse) {\r\n  /* Given a map of squares -> candiates, using depth-first search,\r\n  recursively try all possible values until a solution is found, or false\r\n  if no solution exists.\r\n  */\r\n\r\n  // Return if error in previous iteration\r\n  if (!candidates) {\r\n    return false;\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false;\r\n\r\n  // If only one candidate for every square, we've a solved puzzle!\r\n  // Return the candidates map.\r\n  var max_nr_candidates = 0;\r\n  // eslint-disable-next-line\r\n  var max_candidates_square = null;\r\n  for (var si in SQUARES) {\r\n    var square = SQUARES[si];\r\n\r\n    var nr_candidates = candidates[square].length;\r\n\r\n    if (nr_candidates > max_nr_candidates) {\r\n      max_nr_candidates = nr_candidates;\r\n      // eslint-disable-next-line no-unused-vars\r\n      max_candidates_square = square;\r\n    }\r\n  }\r\n  if (max_nr_candidates === 1) {\r\n    return candidates;\r\n  }\r\n\r\n  // Choose the blank square with the fewest possibilities > 1\r\n  var min_nr_candidates = 10;\r\n  var min_candidates_square = null;\r\n  for (si in SQUARES) {\r\n    square = SQUARES[si];\r\n\r\n    nr_candidates = candidates[square].length;\r\n\r\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\r\n      min_nr_candidates = nr_candidates;\r\n      min_candidates_square = square;\r\n    }\r\n  }\r\n\r\n  // Recursively search through each of the candidates of the square\r\n  // starting with the one with fewest candidates.\r\n\r\n  // Rotate through the candidates forwards\r\n  var min_candidates = candidates[min_candidates_square];\r\n  if (!reverse) {\r\n    for (var vi in min_candidates) {\r\n      var val = min_candidates[vi];\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      var candidates_copy = JSON.parse(JSON.stringify(candidates));\r\n      var candidates_next = sudoku._search(\r\n        sudoku._assign(candidates_copy, min_candidates_square, val)\r\n      );\r\n\r\n      if (candidates_next) {\r\n        return candidates_next;\r\n      }\r\n    }\r\n\r\n    // Rotate through the candidates backwards\r\n  } else {\r\n    for (vi = min_candidates.length - 1; vi >= 0; --vi) {\r\n      val = min_candidates[vi];\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      candidates_copy = JSON.parse(JSON.stringify(candidates));\r\n      candidates_next = sudoku._search(\r\n        sudoku._assign(candidates_copy, min_candidates_square, val),\r\n        reverse\r\n      );\r\n\r\n      if (candidates_next) {\r\n        return candidates_next;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we get through all combinations of the square with the fewest\r\n  // candidates without finding an answer, there isn't one. Return false.\r\n  return false;\r\n};\r\n\r\nsudoku._assign = function (candidates, square, val) {\r\n  /* Eliminate all values, *except* for `val`, from `candidates` at\r\n  `square` (candidates[square]), and propagate. Return the candidates map\r\n  when finished. If a contradiciton is found, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */\r\n\r\n  // Grab a list of canidates without 'val'\r\n  var other_vals = candidates[square].replace(val, \"\");\r\n\r\n  // Loop through all other values and eliminate them from the candidates\r\n  // at the current square, and propigate. If at any point we get a\r\n  // contradiction, return false.\r\n  for (var ovi in other_vals) {\r\n    var other_val = other_vals[ovi];\r\n\r\n    var candidates_next =\r\n      sudoku._eliminate(candidates, square, other_val);\r\n\r\n    if (!candidates_next) {\r\n      //console.log(\"Contradiction found by _eliminate.\");\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return candidates;\r\n};\r\n\r\nsudoku._eliminate = function (candidates, square, val) {\r\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n  and propagate when values or places <= 2. Return updated candidates,\r\n  unless a contradiction is detected, in which case, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */\r\n\r\n  // If `val` has already been eliminated from candidates[square], return\r\n  // with candidates.\r\n  if (!sudoku._in(val, candidates[square])) {\r\n    return candidates;\r\n  }\r\n\r\n  // Remove `val` from candidates[square]\r\n  candidates[square] = candidates[square].replace(val, '');\r\n\r\n  // If the square has only candidate left, eliminate that value from its\r\n  // peers\r\n  var nr_candidates = candidates[square].length;\r\n  if (nr_candidates === 1) {\r\n    var target_val = candidates[square];\r\n\r\n    for (var pi in SQUARE_PEERS_MAP[square]) {\r\n      var peer = SQUARE_PEERS_MAP[square][pi];\r\n\r\n      var candidates_new =\r\n        sudoku._eliminate(candidates, peer, target_val);\r\n\r\n      if (!candidates_new) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Otherwise, if the square has no candidates, we have a contradiction.\r\n    // Return false.\r\n  } if (nr_candidates === 0) {\r\n    return false;\r\n  }\r\n\r\n  // If a unit is reduced to only one place for a value, then assign it\r\n  for (var ui in SQUARE_UNITS_MAP[square]) {\r\n    var unit = SQUARE_UNITS_MAP[square][ui];\r\n\r\n    var val_places = [];\r\n    for (var si in unit) {\r\n      var unit_square = unit[si];\r\n      if (sudoku._in(val, candidates[unit_square])) {\r\n        val_places.push(unit_square);\r\n      }\r\n    }\r\n\r\n    // If there's no place for this value, we have a contradition!\r\n    // return false\r\n    if (val_places.length === 0) {\r\n      return false;\r\n\r\n      // Otherwise the value can only be in one place. Assign it there.\r\n    } else if (val_places.length === 1) {\r\n      candidates_new =\r\n        sudoku._assign(candidates, val_places[0], val);\r\n\r\n      if (!candidates_new) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidates;\r\n};\r\n\r\n\r\n// Square relationships\r\n// -------------------------------------------------------------------------\r\n// Squares, and their relationships with values, units, and peers.\r\n\r\nsudoku._get_square_vals_map = function (board) {\r\n  /* Return a map of squares -> values\r\n  */\r\n  var squares_vals_map = {};\r\n\r\n  // Make sure `board` is a string of length 81\r\n  if (board.length !== SQUARES.length) {\r\n    // eslint-disable-next-line\r\n    throw \"Board/squares length mismatch.\";\r\n\r\n  } else {\r\n    for (var i in SQUARES) {\r\n      squares_vals_map[SQUARES[i]] = board[i];\r\n    }\r\n  }\r\n\r\n  return squares_vals_map;\r\n};\r\n\r\nsudoku._get_square_units_map = function (squares, units) {\r\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n  */\r\n  var square_unit_map = {};\r\n\r\n  // For every square...\r\n  for (var si in squares) {\r\n    var cur_square = squares[si];\r\n\r\n    // Maintain a list of the current square's units\r\n    var cur_square_units = [];\r\n\r\n    // Look through the units, and see if the current square is in it,\r\n    // and if so, add it to the list of of the square's units.\r\n    for (var ui in units) {\r\n      var cur_unit = units[ui];\r\n\r\n      if (cur_unit.indexOf(cur_square) !== -1) {\r\n        cur_square_units.push(cur_unit);\r\n      }\r\n    }\r\n\r\n    // Save the current square and its units to the map\r\n    square_unit_map[cur_square] = cur_square_units;\r\n  }\r\n\r\n  return square_unit_map;\r\n};\r\n\r\nsudoku._get_square_peers_map = function (squares, units_map) {\r\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n  other squares in the square's unit.\r\n  */\r\n  var square_peers_map = {};\r\n\r\n  // For every square...\r\n  for (var si in squares) {\r\n    var cur_square = squares[si];\r\n    var cur_square_units = units_map[cur_square];\r\n\r\n    // Maintain list of the current square's peers\r\n    var cur_square_peers = [];\r\n\r\n    // Look through the current square's units map...\r\n    for (var sui in cur_square_units) {\r\n      var cur_unit = cur_square_units[sui];\r\n\r\n      for (var ui in cur_unit) {\r\n        var cur_unit_square = cur_unit[ui];\r\n\r\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 &&\r\n          cur_unit_square !== cur_square) {\r\n          cur_square_peers.push(cur_unit_square);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save the current square an its associated peers to the map\r\n    square_peers_map[cur_square] = cur_square_peers;\r\n  }\r\n\r\n  return square_peers_map;\r\n};\r\n\r\nsudoku._get_all_units = function (rows, cols) {\r\n  /* Return a list of all units (rows, cols, boxes)\r\n  */\r\n  var units = [];\r\n\r\n  // Rows\r\n  for (var ri in rows) {\r\n    units.push(sudoku._cross(rows[ri], cols));\r\n  }\r\n\r\n  // Columns\r\n  for (var ci in cols) {\r\n    units.push(sudoku._cross(rows, cols[ci]));\r\n  }\r\n\r\n  // Boxes\r\n  var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\r\n  var col_squares = [\"123\", \"456\", \"789\"];\r\n  for (var rsi in row_squares) {\r\n    for (var csi in col_squares) {\r\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\r\n    }\r\n  }\r\n\r\n  return units;\r\n};\r\n\r\n\r\n// Conversions\r\n// -------------------------------------------------------------------------\r\nsudoku.board_string_to_grid = function (board_string) {\r\n  /* Convert a board string to a two-dimensional array\r\n  */\r\n  var rows = [];\r\n  var cur_row = [];\r\n  for (var i in board_string) {\r\n    cur_row.push(board_string[i]);\r\n    if (i % 9 === 8) {\r\n      rows.push(cur_row);\r\n      cur_row = [];\r\n    }\r\n  }\r\n  return rows;\r\n};\r\n\r\nsudoku.board_grid_to_string = function (board_grid) {\r\n  /* Convert a board grid to a string\r\n  */\r\n  var board_string = \"\";\r\n  for (var r = 0; r < 9; ++r) {\r\n    for (var c = 0; c < 9; ++c) {\r\n      board_string += board_grid[r][c];\r\n    }\r\n  }\r\n  return board_string;\r\n};\r\n\r\n\r\n// Utility\r\n// -------------------------------------------------------------------------\r\n\r\nsudoku.print_board = function (board) {\r\n  /* Print a sudoku `board` to the console.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  var V_PADDING = \" \";  // Insert after each square\r\n  var H_PADDING = '\\n'; // Insert after each row\r\n\r\n  var V_BOX_PADDING = \"  \"; // Box vertical padding\r\n  var H_BOX_PADDING = '\\n'; // Box horizontal padding\r\n\r\n  var display_string = \"\";\r\n\r\n  for (var i in board) {\r\n    var square = board[i];\r\n\r\n    // Add the square and some padding\r\n    display_string += square + V_PADDING;\r\n\r\n    // Vertical edge of a box, insert v. box padding\r\n    if (i % 3 === 2) {\r\n      display_string += V_BOX_PADDING;\r\n    }\r\n\r\n    // End of a line, insert horiz. padding\r\n    if (i % 9 === 8) {\r\n      display_string += H_PADDING;\r\n    }\r\n\r\n    // Horizontal edge of a box, insert h. box padding\r\n    if (i % 27 === 26) {\r\n      display_string += H_BOX_PADDING;\r\n    }\r\n  }\r\n\r\n  console.log(display_string);\r\n};\r\n\r\nsudoku.validate_board = function (board) {\r\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n  true. If it's not, return a string of the reason why it's not.\r\n  */\r\n\r\n  // Check for empty board\r\n  if (!board) {\r\n    return \"Empty board\";\r\n  }\r\n\r\n  // Invalid board length\r\n  if (board.length !== NR_SQUARES) {\r\n    return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\r\n      \" squares.\";\r\n  }\r\n\r\n  // Check for invalid characters\r\n  for (var i in board) {\r\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\r\n      return \"Invalid board character encountered at index \" + i +\r\n        \": \" + board[i];\r\n    }\r\n  }\r\n\r\n  // Otherwise, we're good. Return true.\r\n  return true;\r\n};\r\n\r\nsudoku._cross = function (a, b) {\r\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n  sudoku._cross(\"abc\", \"123\") ->\r\n  [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n  */\r\n  var result = [];\r\n  for (var ai in a) {\r\n    for (var bi in b) {\r\n      result.push(a[ai] + b[bi]);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nsudoku._in = function (v, seq) {\r\n  /* Return if a value `v` is in sequence `seq`.\r\n  */\r\n  return seq.indexOf(v) !== -1;\r\n};\r\n\r\nsudoku._first_true = function (seq) {\r\n  /* Return the first element in `seq` that is true. If no element is\r\n  true, return false.\r\n  */\r\n  for (var i in seq) {\r\n    if (seq[i]) {\r\n      return seq[i];\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nsudoku._shuffle = function (seq) {\r\n  /* Return a shuffled version of `seq`\r\n  */\r\n\r\n  // Create an array of the same size as `seq` filled with false\r\n  var shuffled = [];\r\n  for (var i = 0; i < seq.length; ++i) {\r\n    shuffled.push(false);\r\n  }\r\n\r\n  for (i in seq) {\r\n    var ti = sudoku._rand_range(seq.length);\r\n\r\n    while (shuffled[ti]) {\r\n      ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\r\n    }\r\n\r\n    shuffled[ti] = seq[i];\r\n  }\r\n\r\n  return shuffled;\r\n};\r\n\r\nsudoku._rand_range = function (max, min) {\r\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n  If `min` not defined, default to 0. If `max` not defined, throw an\r\n  error.\r\n  */\r\n  min = min || 0;\r\n  if (max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  } else {\r\n    // eslint-disable-next-line\r\n    throw \"Range undefined\";\r\n  }\r\n};\r\n\r\nsudoku._strip_dups = function (seq) {\r\n  /* Strip duplicate values from `seq`\r\n  */\r\n  var seq_set = [];\r\n  var dup_map = {};\r\n  for (var i in seq) {\r\n    var e = seq[i];\r\n    if (!dup_map[e]) {\r\n      seq_set.push(e);\r\n      dup_map[e] = true;\r\n    }\r\n  }\r\n  return seq_set;\r\n};\r\n\r\nsudoku._force_range = function (nr, max, min) {\r\n  /* Force `nr` to be within the range from `min` to, but not including,\r\n  `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n  treat it as zero.\r\n  */\r\n  min = min || 0\r\n  nr = nr || 0\r\n  if (nr < min) {\r\n    return min;\r\n  }\r\n  if (nr > max) {\r\n    return max;\r\n  }\r\n  return nr\r\n}\r\n\r\n// Initialize library after load\r\ninitialize();\r\n\r\nexport const getSudoku = () => {\r\n  return sudoku;\r\n}\r\n\r\n// Pass whatever the root object is, like 'window' in browsers\r\n//})(this);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}