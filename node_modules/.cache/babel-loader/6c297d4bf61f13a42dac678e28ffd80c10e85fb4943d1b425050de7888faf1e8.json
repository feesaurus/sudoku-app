{"ast":null,"code":"/*\r\n    Sudoku.js\r\n    ---------\r\n\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n\r\n    Please see the README for more details.\r\n*/\n\n//(function(root){\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\nvar sudoku = {};\nsudoku.DIGITS = \"123456789\"; // Allowed sudoku.DIGITS\nvar ROWS = \"ABCDEFGHI\"; // Row lables\nvar COLS = sudoku.DIGITS; // Column lables\nvar SQUARES = null; // Square IDs\n\nvar UNITS = null; // All units (row, column, or box)\nvar SQUARE_UNITS_MAP = null; // Squares -> units map\nvar SQUARE_PEERS_MAP = null; // Squares -> peers map\n\nvar MIN_GIVENS = 17; // Minimum number of givens\nvar NR_SQUARES = 81; // Number of squares\n\n// Define difficulties by how many squares are given to the player in a new\n// puzzle.\nvar DIFFICULTY = {\n  \"easy\": 62,\n  \"medium\": 53,\n  \"hard\": 44,\n  \"very-hard\": 35,\n  \"insane\": 26,\n  \"inhuman\": 17\n};\n\n// Blank character and board representation\nsudoku.BLANK_CHAR = '.';\nsudoku.BLANK_BOARD = \"....................................................\" + \".............................\";\n\n// Init\n// -------------------------------------------------------------------------\nfunction initialize() {\n  /* Initialize the Sudoku library (invoked after library load)\r\n  */\n  SQUARES = sudoku._cross(ROWS, COLS);\n  UNITS = sudoku._get_all_units(ROWS, COLS);\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS);\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES, SQUARE_UNITS_MAP);\n}\n\n// Generate\n// -------------------------------------------------------------------------\nsudoku.generate = function (difficulty, unique) {\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n        // Generate an \"easy\" sudoku puzzle\r\n      sudoku.generate(\"easy\");\r\n  \r\n  Difficulties are as follows, and represent the number of given squares:\r\n            \"easy\":         61\r\n          \"medium\":       52\r\n          \"hard\":         43\r\n          \"very-hard\":    34\r\n          \"insane\":       25\r\n          \"inhuman\":      17\r\n  \r\n  You may also enter a custom number of squares to be given, e.g.,\r\n        // Generate a new Sudoku puzzle with 60 given squares\r\n      sudoku.generate(60)\r\n  \r\n  `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n  outside of that range, `difficulty` will be set to the closest bound,\r\n  e.g., 0 -> 17, and 100 -> 81.\r\n  \r\n  By default, the puzzles are unique, uless you set `unique` to false.\r\n  (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\r\n  guaranteed to have unique solutions)\r\n    TODO: Implement puzzle uniqueness\r\n  */\n\n  // If `difficulty` is a string or undefined, convert it to a number or\n  // default it to \"easy\" if undefined.\n  if (typeof difficulty === \"string\" || typeof difficulty === \"undefined\") {\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\n  }\n\n  // Force difficulty between 17 and 81 inclusive\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1, MIN_GIVENS);\n\n  // Default unique to true\n  unique = unique || true;\n\n  // Get a set of squares and all possible candidates for each square\n  var blank_board = \"\";\n  for (var i = 0; i < NR_SQUARES; ++i) {\n    blank_board += '.';\n  }\n  var candidates = sudoku._get_candidates_map(blank_board);\n\n  // For each item in a shuffled list of squares\n  var shuffled_squares = sudoku._shuffle(SQUARES);\n  for (var si in shuffled_squares) {\n    var square = shuffled_squares[si];\n\n    // If an assignment of a random chioce causes a contradictoin, give\n    // up and try again\n    var rand_candidate_idx = sudoku._rand_range(candidates[square].length);\n    var rand_candidate = candidates[square][rand_candidate_idx];\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\n      break;\n    }\n\n    // Make a list of all single candidates\n    var single_candidates = [];\n    for (si in SQUARES) {\n      square = SQUARES[si];\n      if (candidates[square].length === 1) {\n        single_candidates.push(candidates[square]);\n      }\n    }\n\n    // If we have at least difficulty, and the unique candidate count is\n    // at least 8, return the puzzle!\n    if (single_candidates.length >= difficulty && sudoku._strip_dups(single_candidates).length >= 8) {\n      var board = \"\";\n      var givens_idxs = [];\n      for (i in SQUARES) {\n        square = SQUARES[i];\n        if (candidates[square].length === 1) {\n          board += candidates[square];\n          givens_idxs.push(i);\n        } else {\n          board += sudoku.BLANK_CHAR;\n        }\n      }\n\n      // If we have more than `difficulty` givens, remove some random\n      // givens until we're down to exactly `difficulty`\n      var nr_givens = givens_idxs.length;\n      if (nr_givens > difficulty) {\n        givens_idxs = sudoku._shuffle(givens_idxs);\n        for (i = 0; i < nr_givens - difficulty; ++i) {\n          var target = parseInt(givens_idxs[i]);\n          board = board.substr(0, target) + sudoku.BLANK_CHAR + board.substr(target + 1);\n        }\n      }\n\n      // Double check board is solvable\n      // TODO: Make a standalone board checker. Solve is expensive.\n      if (sudoku.solve(board)) {\n        return board;\n      }\n    }\n  }\n\n  // Give up and try a new puzzle\n  return sudoku.generate(difficulty);\n};\n\n// Solve\n// -------------------------------------------------------------------------\nsudoku.solve = function (board, reverse) {\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\r\n  string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n  squares. There must be a minimum of 17 givens. If the given board has no\r\n  solutions, return false.\r\n    Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n  possibilities in reverse. Useful for checking if there is more than one\r\n  solution.\r\n  */\n\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n  if (report !== true) {\n    throw report;\n  }\n\n  // Check number of givens is at least MIN_GIVENS\n  var nr_givens = 0;\n  for (var i in board) {\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\n      ++nr_givens;\n    }\n  }\n  if (nr_givens < MIN_GIVENS) {\n    // eslint-disable-next-line\n    throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\n  }\n\n  // Default reverse to false\n  reverse = reverse || false;\n  var candidates = sudoku._get_candidates_map(board);\n  var result = sudoku._search(candidates, reverse);\n  if (result) {\n    var solution = \"\";\n    for (var square in result) {\n      solution += result[square];\n    }\n    return solution;\n  }\n  return false;\n};\nsudoku.get_candidates = function (board) {\n  /* Return all possible candidatees for each square as a grid of\r\n  candidates, returnning `false` if a contradiction is encountered.\r\n    Really just a wrapper for sudoku._get_candidates_map for programmer\r\n  consumption.\r\n  */\n\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n  if (report !== true) {\n    throw report;\n  }\n\n  // Get a candidates map\n  var candidates_map = sudoku._get_candidates_map(board);\n\n  // If there's an error, return false\n  if (!candidates_map) {\n    return false;\n  }\n\n  // Transform candidates map into grid\n  var rows = [];\n  var cur_row = [];\n  var i = 0;\n  for (var square in candidates_map) {\n    var candidates = candidates_map[square];\n    cur_row.push(candidates);\n    if (i % 9 === 8) {\n      rows.push(cur_row);\n      cur_row = [];\n    }\n    ++i;\n  }\n  return rows;\n};\nsudoku._get_candidates_map = function (board) {\n  /* Get all possible candidates for each square as a map in the form\r\n  {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\r\n  if a contradiction is encountered\r\n  */\n\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n  if (report !== true) {\n    throw report;\n  }\n  var candidate_map = {};\n  var squares_values_map = sudoku._get_square_vals_map(board);\n\n  // Start by assigning every digit as a candidate to every square\n  for (var si in SQUARES) {\n    candidate_map[SQUARES[si]] = sudoku.DIGITS;\n  }\n\n  // For each non-blank square, assign its value in the candidate map and\n  // propigate.\n  for (var square in squares_values_map) {\n    var val = squares_values_map[square];\n    if (sudoku._in(val, sudoku.DIGITS)) {\n      var new_candidates = sudoku._assign(candidate_map, square, val);\n\n      // Fail if we can't assign val to square\n      if (!new_candidates) {\n        return false;\n      }\n    }\n  }\n  return candidate_map;\n};\nsudoku._search = function (candidates, reverse) {\n  /* Given a map of squares -> candiates, using depth-first search,\r\n  recursively try all possible values until a solution is found, or false\r\n  if no solution exists.\r\n  */\n\n  // Return if error in previous iteration\n  if (!candidates) {\n    return false;\n  }\n\n  // Default reverse to false\n  reverse = reverse || false;\n\n  // If only one candidate for every square, we've a solved puzzle!\n  // Return the candidates map.\n  var max_nr_candidates = 0;\n  // eslint-disable-next-line\n  var max_candidates_square = null;\n  for (var si in SQUARES) {\n    var square = SQUARES[si];\n    var nr_candidates = candidates[square].length;\n    if (nr_candidates > max_nr_candidates) {\n      max_nr_candidates = nr_candidates;\n      // eslint-disable-next-line no-unused-vars\n      max_candidates_square = square;\n    }\n  }\n  if (max_nr_candidates === 1) {\n    return candidates;\n  }\n\n  // Choose the blank square with the fewest possibilities > 1\n  var min_nr_candidates = 10;\n  var min_candidates_square = null;\n  for (si in SQUARES) {\n    square = SQUARES[si];\n    nr_candidates = candidates[square].length;\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\n      min_nr_candidates = nr_candidates;\n      min_candidates_square = square;\n    }\n  }\n\n  // Recursively search through each of the candidates of the square\n  // starting with the one with fewest candidates.\n\n  // Rotate through the candidates forwards\n  var min_candidates = candidates[min_candidates_square];\n  if (!reverse) {\n    for (var vi in min_candidates) {\n      var val = min_candidates[vi];\n\n      // TODO: Implement a non-rediculous deep copy function\n      var candidates_copy = JSON.parse(JSON.stringify(candidates));\n      var candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val));\n      if (candidates_next) {\n        return candidates_next;\n      }\n    }\n\n    // Rotate through the candidates backwards\n  } else {\n    for (vi = min_candidates.length - 1; vi >= 0; --vi) {\n      val = min_candidates[vi];\n\n      // TODO: Implement a non-rediculous deep copy function\n      candidates_copy = JSON.parse(JSON.stringify(candidates));\n      candidates_next = sudoku._search(sudoku._assign(candidates_copy, min_candidates_square, val), reverse);\n      if (candidates_next) {\n        return candidates_next;\n      }\n    }\n  }\n\n  // If we get through all combinations of the square with the fewest\n  // candidates without finding an answer, there isn't one. Return false.\n  return false;\n};\nsudoku._assign = function (candidates, square, val) {\n  /* Eliminate all values, *except* for `val`, from `candidates` at\r\n  `square` (candidates[square]), and propagate. Return the candidates map\r\n  when finished. If a contradiciton is found, return false.\r\n    WARNING: This will modify the contents of `candidates` directly.\r\n  */\n\n  // Grab a list of canidates without 'val'\n  var other_vals = candidates[square].replace(val, \"\");\n\n  // Loop through all other values and eliminate them from the candidates\n  // at the current square, and propigate. If at any point we get a\n  // contradiction, return false.\n  for (var ovi in other_vals) {\n    var other_val = other_vals[ovi];\n    var candidates_next = sudoku._eliminate(candidates, square, other_val);\n    if (!candidates_next) {\n      //console.log(\"Contradiction found by _eliminate.\");\n      return false;\n    }\n  }\n  return candidates;\n};\nsudoku._eliminate = function (candidates, square, val) {\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n  and propagate when values or places <= 2. Return updated candidates,\r\n  unless a contradiction is detected, in which case, return false.\r\n    WARNING: This will modify the contents of `candidates` directly.\r\n  */\n\n  // If `val` has already been eliminated from candidates[square], return\n  // with candidates.\n  if (!sudoku._in(val, candidates[square])) {\n    return candidates;\n  }\n\n  // Remove `val` from candidates[square]\n  candidates[square] = candidates[square].replace(val, '');\n\n  // If the square has only candidate left, eliminate that value from its\n  // peers\n  var nr_candidates = candidates[square].length;\n  if (nr_candidates === 1) {\n    var target_val = candidates[square];\n    for (var pi in SQUARE_PEERS_MAP[square]) {\n      var peer = SQUARE_PEERS_MAP[square][pi];\n      var candidates_new = sudoku._eliminate(candidates, peer, target_val);\n      if (!candidates_new) {\n        return false;\n      }\n    }\n\n    // Otherwise, if the square has no candidates, we have a contradiction.\n    // Return false.\n  }\n  if (nr_candidates === 0) {\n    return false;\n  }\n\n  // If a unit is reduced to only one place for a value, then assign it\n  for (var ui in SQUARE_UNITS_MAP[square]) {\n    var unit = SQUARE_UNITS_MAP[square][ui];\n    var val_places = [];\n    for (var si in unit) {\n      var unit_square = unit[si];\n      if (sudoku._in(val, candidates[unit_square])) {\n        val_places.push(unit_square);\n      }\n    }\n\n    // If there's no place for this value, we have a contradition!\n    // return false\n    if (val_places.length === 0) {\n      return false;\n\n      // Otherwise the value can only be in one place. Assign it there.\n    } else if (val_places.length === 1) {\n      candidates_new = sudoku._assign(candidates, val_places[0], val);\n      if (!candidates_new) {\n        return false;\n      }\n    }\n  }\n  return candidates;\n};\n\n// Square relationships\n// -------------------------------------------------------------------------\n// Squares, and their relationships with values, units, and peers.\n\nsudoku._get_square_vals_map = function (board) {\n  /* Return a map of squares -> values\r\n  */\n  var squares_vals_map = {};\n\n  // Make sure `board` is a string of length 81\n  if (board.length !== SQUARES.length) {\n    // eslint-disable-next-line\n    throw \"Board/squares length mismatch.\";\n  } else {\n    for (var i in SQUARES) {\n      squares_vals_map[SQUARES[i]] = board[i];\n    }\n  }\n  return squares_vals_map;\n};\nsudoku._get_square_units_map = function (squares, units) {\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n  */\n  var square_unit_map = {};\n\n  // For every square...\n  for (var si in squares) {\n    var cur_square = squares[si];\n\n    // Maintain a list of the current square's units\n    var cur_square_units = [];\n\n    // Look through the units, and see if the current square is in it,\n    // and if so, add it to the list of of the square's units.\n    for (var ui in units) {\n      var cur_unit = units[ui];\n      if (cur_unit.indexOf(cur_square) !== -1) {\n        cur_square_units.push(cur_unit);\n      }\n    }\n\n    // Save the current square and its units to the map\n    square_unit_map[cur_square] = cur_square_units;\n  }\n  return square_unit_map;\n};\nsudoku._get_square_peers_map = function (squares, units_map) {\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n  other squares in the square's unit.\r\n  */\n  var square_peers_map = {};\n\n  // For every square...\n  for (var si in squares) {\n    var cur_square = squares[si];\n    var cur_square_units = units_map[cur_square];\n\n    // Maintain list of the current square's peers\n    var cur_square_peers = [];\n\n    // Look through the current square's units map...\n    for (var sui in cur_square_units) {\n      var cur_unit = cur_square_units[sui];\n      for (var ui in cur_unit) {\n        var cur_unit_square = cur_unit[ui];\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 && cur_unit_square !== cur_square) {\n          cur_square_peers.push(cur_unit_square);\n        }\n      }\n    }\n\n    // Save the current square an its associated peers to the map\n    square_peers_map[cur_square] = cur_square_peers;\n  }\n  return square_peers_map;\n};\nsudoku._get_all_units = function (rows, cols) {\n  /* Return a list of all units (rows, cols, boxes)\r\n  */\n  var units = [];\n\n  // Rows\n  for (var ri in rows) {\n    units.push(sudoku._cross(rows[ri], cols));\n  }\n\n  // Columns\n  for (var ci in cols) {\n    units.push(sudoku._cross(rows, cols[ci]));\n  }\n\n  // Boxes\n  var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\n  var col_squares = [\"123\", \"456\", \"789\"];\n  for (var rsi in row_squares) {\n    for (var csi in col_squares) {\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\n    }\n  }\n  return units;\n};\n\n// Conversions\n// -------------------------------------------------------------------------\nsudoku.board_string_to_grid = function (board_string) {\n  /* Convert a board string to a two-dimensional array\r\n  */\n  var rows = [];\n  var cur_row = [];\n  for (var i in board_string) {\n    cur_row.push(board_string[i]);\n    if (i % 9 === 8) {\n      rows.push(cur_row);\n      cur_row = [];\n    }\n  }\n  return rows;\n};\nsudoku.board_grid_to_string = function (board_grid) {\n  /* Convert a board grid to a string\r\n  */\n  var board_string = \"\";\n  for (var r = 0; r < 9; ++r) {\n    for (var c = 0; c < 9; ++c) {\n      board_string += board_grid[r][c];\n    }\n  }\n  return board_string;\n};\n\n// Utility\n// -------------------------------------------------------------------------\n\nsudoku.print_board = function (board) {\n  /* Print a sudoku `board` to the console.\r\n  */\n\n  // Assure a valid board\n  var report = sudoku.validate_board(board);\n  if (report !== true) {\n    throw report;\n  }\n  var V_PADDING = \" \"; // Insert after each square\n  var H_PADDING = '\\n'; // Insert after each row\n\n  var V_BOX_PADDING = \"  \"; // Box vertical padding\n  var H_BOX_PADDING = '\\n'; // Box horizontal padding\n\n  var display_string = \"\";\n  for (var i in board) {\n    var square = board[i];\n\n    // Add the square and some padding\n    display_string += square + V_PADDING;\n\n    // Vertical edge of a box, insert v. box padding\n    if (i % 3 === 2) {\n      display_string += V_BOX_PADDING;\n    }\n\n    // End of a line, insert horiz. padding\n    if (i % 9 === 8) {\n      display_string += H_PADDING;\n    }\n\n    // Horizontal edge of a box, insert h. box padding\n    if (i % 27 === 26) {\n      display_string += H_BOX_PADDING;\n    }\n  }\n  console.log(display_string);\n};\nsudoku.validate_board = function (board) {\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n  true. If it's not, return a string of the reason why it's not.\r\n  */\n\n  // Check for empty board\n  if (!board) {\n    return \"Empty board\";\n  }\n\n  // Invalid board length\n  if (board.length !== NR_SQUARES) {\n    return \"Invalid board size. Board must be exactly \" + NR_SQUARES + \" squares.\";\n  }\n\n  // Check for invalid characters\n  for (var i in board) {\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\n      return \"Invalid board character encountered at index \" + i + \": \" + board[i];\n    }\n  }\n\n  // Otherwise, we're good. Return true.\n  return true;\n};\nsudoku._cross = function (a, b) {\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n  sudoku._cross(\"abc\", \"123\") ->\r\n  [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n  */\n  var result = [];\n  for (var ai in a) {\n    for (var bi in b) {\n      result.push(a[ai] + b[bi]);\n    }\n  }\n  return result;\n};\nsudoku._in = function (v, seq) {\n  /* Return if a value `v` is in sequence `seq`.\r\n  */\n  return seq.indexOf(v) !== -1;\n};\nsudoku._first_true = function (seq) {\n  /* Return the first element in `seq` that is true. If no element is\r\n  true, return false.\r\n  */\n  for (var i in seq) {\n    if (seq[i]) {\n      return seq[i];\n    }\n  }\n  return false;\n};\nsudoku._shuffle = function (seq) {\n  /* Return a shuffled version of `seq`\r\n  */\n\n  // Create an array of the same size as `seq` filled with false\n  var shuffled = [];\n  for (var i = 0; i < seq.length; ++i) {\n    shuffled.push(false);\n  }\n  for (i in seq) {\n    var ti = sudoku._rand_range(seq.length);\n    while (shuffled[ti]) {\n      ti = ti + 1 > seq.length - 1 ? 0 : ti + 1;\n    }\n    shuffled[ti] = seq[i];\n  }\n  return shuffled;\n};\nsudoku._rand_range = function (max, min) {\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n  If `min` not defined, default to 0. If `max` not defined, throw an\r\n  error.\r\n  */\n  min = min || 0;\n  if (max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n  } else {\n    // eslint-disable-next-line\n    throw \"Range undefined\";\n  }\n};\nsudoku._strip_dups = function (seq) {\n  /* Strip duplicate values from `seq`\r\n  */\n  var seq_set = [];\n  var dup_map = {};\n  for (var i in seq) {\n    var e = seq[i];\n    if (!dup_map[e]) {\n      seq_set.push(e);\n      dup_map[e] = true;\n    }\n  }\n  return seq_set;\n};\nsudoku._force_range = function (nr, max, min) {\n  /* Force `nr` to be within the range from `min` to, but not including,\r\n  `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n  treat it as zero.\r\n  */\n  min = min || 0;\n  nr = nr || 0;\n  if (nr < min) {\n    return min;\n  }\n  if (nr > max) {\n    return max;\n  }\n  return nr;\n};\n\n// Initialize library after load\ninitialize();\nexport const getSudoku = () => {\n  return sudoku;\n};\n\n// Pass whatever the root object is, like 'window' in browsers\n//})(this);","map":{"version":3,"names":["sudoku","DIGITS","ROWS","COLS","SQUARES","UNITS","SQUARE_UNITS_MAP","SQUARE_PEERS_MAP","MIN_GIVENS","NR_SQUARES","DIFFICULTY","BLANK_CHAR","BLANK_BOARD","initialize","_cross","_get_all_units","_get_square_units_map","_get_square_peers_map","generate","difficulty","unique","easy","_force_range","blank_board","i","candidates","_get_candidates_map","shuffled_squares","_shuffle","si","square","rand_candidate_idx","_rand_range","length","rand_candidate","_assign","single_candidates","push","_strip_dups","board","givens_idxs","nr_givens","target","parseInt","substr","solve","reverse","report","validate_board","_in","result","_search","solution","get_candidates","candidates_map","rows","cur_row","candidate_map","squares_values_map","_get_square_vals_map","val","new_candidates","max_nr_candidates","max_candidates_square","nr_candidates","min_nr_candidates","min_candidates_square","min_candidates","vi","candidates_copy","JSON","parse","stringify","candidates_next","other_vals","replace","ovi","other_val","_eliminate","target_val","pi","peer","candidates_new","ui","unit","val_places","unit_square","squares_vals_map","squares","units","square_unit_map","cur_square","cur_square_units","cur_unit","indexOf","units_map","square_peers_map","cur_square_peers","sui","cur_unit_square","cols","ri","ci","row_squares","col_squares","rsi","csi","board_string_to_grid","board_string","board_grid_to_string","board_grid","r","c","print_board","V_PADDING","H_PADDING","V_BOX_PADDING","H_BOX_PADDING","display_string","console","log","a","b","ai","bi","v","seq","_first_true","shuffled","ti","max","min","Math","floor","random","seq_set","dup_map","e","nr","getSudoku"],"sources":["C:/Users/NEXSOFT/Documents/.practice/sudoku-app/src/solver/sudoku.js"],"sourcesContent":["/*\r\n    Sudoku.js\r\n    ---------\r\n\r\n    A Sudoku puzzle generator and solver JavaScript library.\r\n\r\n    Please see the README for more details.\r\n*/\r\n\r\n//(function(root){\r\n//var sudoku = root.sudoku = {};  // Global reference to the sudoku library\r\nvar sudoku = {};\r\nsudoku.DIGITS = \"123456789\";    // Allowed sudoku.DIGITS\r\nvar ROWS = \"ABCDEFGHI\";         // Row lables\r\nvar COLS = sudoku.DIGITS;       // Column lables\r\nvar SQUARES = null;             // Square IDs\r\n\r\nvar UNITS = null;               // All units (row, column, or box)\r\nvar SQUARE_UNITS_MAP = null;    // Squares -> units map\r\nvar SQUARE_PEERS_MAP = null;    // Squares -> peers map\r\n\r\nvar MIN_GIVENS = 17;            // Minimum number of givens\r\nvar NR_SQUARES = 81;            // Number of squares\r\n\r\n// Define difficulties by how many squares are given to the player in a new\r\n// puzzle.\r\nvar DIFFICULTY = {\r\n  \"easy\": 62,\r\n  \"medium\": 53,\r\n  \"hard\": 44,\r\n  \"very-hard\": 35,\r\n  \"insane\": 26,\r\n  \"inhuman\": 17,\r\n};\r\n\r\n// Blank character and board representation\r\nsudoku.BLANK_CHAR = '.';\r\nsudoku.BLANK_BOARD = \"....................................................\" +\r\n  \".............................\";\r\n\r\n// Init\r\n// -------------------------------------------------------------------------\r\nfunction initialize() {\r\n  /* Initialize the Sudoku library (invoked after library load)\r\n  */\r\n  SQUARES = sudoku._cross(ROWS, COLS);\r\n  UNITS = sudoku._get_all_units(ROWS, COLS);\r\n  SQUARE_UNITS_MAP = sudoku._get_square_units_map(SQUARES, UNITS);\r\n  SQUARE_PEERS_MAP = sudoku._get_square_peers_map(SQUARES,\r\n    SQUARE_UNITS_MAP);\r\n}\r\n\r\n// Generate\r\n// -------------------------------------------------------------------------\r\nsudoku.generate = function (difficulty, unique) {\r\n  /* Generate a new Sudoku puzzle of a particular `difficulty`, e.g.,\r\n\r\n      // Generate an \"easy\" sudoku puzzle\r\n      sudoku.generate(\"easy\");\r\n\r\n\r\n  Difficulties are as follows, and represent the number of given squares:\r\n\r\n          \"easy\":         61\r\n          \"medium\":       52\r\n          \"hard\":         43\r\n          \"very-hard\":    34\r\n          \"insane\":       25\r\n          \"inhuman\":      17\r\n\r\n\r\n  You may also enter a custom number of squares to be given, e.g.,\r\n\r\n      // Generate a new Sudoku puzzle with 60 given squares\r\n      sudoku.generate(60)\r\n\r\n\r\n  `difficulty` must be a number between 17 and 81 inclusive. If it's\r\n  outside of that range, `difficulty` will be set to the closest bound,\r\n  e.g., 0 -> 17, and 100 -> 81.\r\n\r\n\r\n  By default, the puzzles are unique, uless you set `unique` to false.\r\n  (Note: Puzzle uniqueness is not yet implemented, so puzzles are *not*\r\n  guaranteed to have unique solutions)\r\n\r\n  TODO: Implement puzzle uniqueness\r\n  */\r\n\r\n  // If `difficulty` is a string or undefined, convert it to a number or\r\n  // default it to \"easy\" if undefined.\r\n  if (typeof difficulty === \"string\" || typeof difficulty === \"undefined\") {\r\n    difficulty = DIFFICULTY[difficulty] || DIFFICULTY.easy;\r\n  }\r\n\r\n  // Force difficulty between 17 and 81 inclusive\r\n  difficulty = sudoku._force_range(difficulty, NR_SQUARES + 1,\r\n    MIN_GIVENS);\r\n\r\n  // Default unique to true\r\n  unique = unique || true;\r\n\r\n  // Get a set of squares and all possible candidates for each square\r\n  var blank_board = \"\";\r\n  for (var i = 0; i < NR_SQUARES; ++i) {\r\n    blank_board += '.';\r\n  }\r\n  var candidates = sudoku._get_candidates_map(blank_board);\r\n\r\n  // For each item in a shuffled list of squares\r\n  var shuffled_squares = sudoku._shuffle(SQUARES);\r\n  for (var si in shuffled_squares) {\r\n    var square = shuffled_squares[si];\r\n\r\n    // If an assignment of a random chioce causes a contradictoin, give\r\n    // up and try again\r\n    var rand_candidate_idx =\r\n      sudoku._rand_range(candidates[square].length);\r\n    var rand_candidate = candidates[square][rand_candidate_idx];\r\n    if (!sudoku._assign(candidates, square, rand_candidate)) {\r\n      break;\r\n    }\r\n\r\n    // Make a list of all single candidates\r\n    var single_candidates = [];\r\n    for (si in SQUARES) {\r\n      square = SQUARES[si];\r\n\r\n      if (candidates[square].length === 1) {\r\n        single_candidates.push(candidates[square]);\r\n      }\r\n    }\r\n\r\n    // If we have at least difficulty, and the unique candidate count is\r\n    // at least 8, return the puzzle!\r\n    if (single_candidates.length >= difficulty &&\r\n      sudoku._strip_dups(single_candidates).length >= 8) {\r\n      var board = \"\";\r\n      var givens_idxs = [];\r\n      for (i in SQUARES) {\r\n        square = SQUARES[i];\r\n        if (candidates[square].length === 1) {\r\n          board += candidates[square];\r\n          givens_idxs.push(i);\r\n        } else {\r\n          board += sudoku.BLANK_CHAR;\r\n        }\r\n      }\r\n\r\n      // If we have more than `difficulty` givens, remove some random\r\n      // givens until we're down to exactly `difficulty`\r\n      var nr_givens = givens_idxs.length;\r\n      if (nr_givens > difficulty) {\r\n        givens_idxs = sudoku._shuffle(givens_idxs);\r\n        for (i = 0; i < nr_givens - difficulty; ++i) {\r\n          var target = parseInt(givens_idxs[i]);\r\n          board = board.substr(0, target) + sudoku.BLANK_CHAR +\r\n            board.substr(target + 1);\r\n        }\r\n      }\r\n\r\n      // Double check board is solvable\r\n      // TODO: Make a standalone board checker. Solve is expensive.\r\n      if (sudoku.solve(board)) {\r\n        return board;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Give up and try a new puzzle\r\n  return sudoku.generate(difficulty);\r\n};\r\n\r\n// Solve\r\n// -------------------------------------------------------------------------\r\nsudoku.solve = function (board, reverse) {\r\n  /* Solve a sudoku puzzle given a sudoku `board`, i.e., an 81-character\r\n  string of sudoku.DIGITS, 1-9, and spaces identified by '.', representing the\r\n  squares. There must be a minimum of 17 givens. If the given board has no\r\n  solutions, return false.\r\n\r\n  Optionally set `reverse` to solve \"backwards\", i.e., rotate through the\r\n  possibilities in reverse. Useful for checking if there is more than one\r\n  solution.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  // Check number of givens is at least MIN_GIVENS\r\n  var nr_givens = 0;\r\n  for (var i in board) {\r\n    if (board[i] !== sudoku.BLANK_CHAR && sudoku._in(board[i], sudoku.DIGITS)) {\r\n      ++nr_givens;\r\n    }\r\n  }\r\n  if (nr_givens < MIN_GIVENS) {\r\n    // eslint-disable-next-line\r\n    throw \"Too few givens. Minimum givens is \" + MIN_GIVENS;\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false;\r\n\r\n  var candidates = sudoku._get_candidates_map(board);\r\n  var result = sudoku._search(candidates, reverse);\r\n\r\n  if (result) {\r\n    var solution = \"\";\r\n    for (var square in result) {\r\n      solution += result[square];\r\n    }\r\n    return solution;\r\n  }\r\n  return false;\r\n};\r\n\r\nsudoku.get_candidates = function (board) {\r\n  /* Return all possible candidatees for each square as a grid of\r\n  candidates, returnning `false` if a contradiction is encountered.\r\n\r\n  Really just a wrapper for sudoku._get_candidates_map for programmer\r\n  consumption.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  // Get a candidates map\r\n  var candidates_map = sudoku._get_candidates_map(board);\r\n\r\n  // If there's an error, return false\r\n  if (!candidates_map) {\r\n    return false;\r\n  }\r\n\r\n  // Transform candidates map into grid\r\n  var rows = [];\r\n  var cur_row = [];\r\n  var i = 0;\r\n  for (var square in candidates_map) {\r\n    var candidates = candidates_map[square];\r\n    cur_row.push(candidates);\r\n    if (i % 9 === 8) {\r\n      rows.push(cur_row);\r\n      cur_row = [];\r\n    }\r\n    ++i;\r\n  }\r\n  return rows;\r\n}\r\n\r\nsudoku._get_candidates_map = function (board) {\r\n  /* Get all possible candidates for each square as a map in the form\r\n  {square: sudoku.DIGITS} using recursive constraint propagation. Return `false`\r\n  if a contradiction is encountered\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  var candidate_map = {};\r\n  var squares_values_map = sudoku._get_square_vals_map(board);\r\n\r\n  // Start by assigning every digit as a candidate to every square\r\n  for (var si in SQUARES) {\r\n    candidate_map[SQUARES[si]] = sudoku.DIGITS;\r\n  }\r\n\r\n  // For each non-blank square, assign its value in the candidate map and\r\n  // propigate.\r\n  for (var square in squares_values_map) {\r\n    var val = squares_values_map[square];\r\n\r\n    if (sudoku._in(val, sudoku.DIGITS)) {\r\n      var new_candidates = sudoku._assign(candidate_map, square, val);\r\n\r\n      // Fail if we can't assign val to square\r\n      if (!new_candidates) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidate_map;\r\n};\r\n\r\nsudoku._search = function (candidates, reverse) {\r\n  /* Given a map of squares -> candiates, using depth-first search,\r\n  recursively try all possible values until a solution is found, or false\r\n  if no solution exists.\r\n  */\r\n\r\n  // Return if error in previous iteration\r\n  if (!candidates) {\r\n    return false;\r\n  }\r\n\r\n  // Default reverse to false\r\n  reverse = reverse || false;\r\n\r\n  // If only one candidate for every square, we've a solved puzzle!\r\n  // Return the candidates map.\r\n  var max_nr_candidates = 0;\r\n  // eslint-disable-next-line\r\n  var max_candidates_square = null;\r\n  for (var si in SQUARES) {\r\n    var square = SQUARES[si];\r\n\r\n    var nr_candidates = candidates[square].length;\r\n\r\n    if (nr_candidates > max_nr_candidates) {\r\n      max_nr_candidates = nr_candidates;\r\n      // eslint-disable-next-line no-unused-vars\r\n      max_candidates_square = square;\r\n    }\r\n  }\r\n  if (max_nr_candidates === 1) {\r\n    return candidates;\r\n  }\r\n\r\n  // Choose the blank square with the fewest possibilities > 1\r\n  var min_nr_candidates = 10;\r\n  var min_candidates_square = null;\r\n  for (si in SQUARES) {\r\n    square = SQUARES[si];\r\n\r\n    nr_candidates = candidates[square].length;\r\n\r\n    if (nr_candidates < min_nr_candidates && nr_candidates > 1) {\r\n      min_nr_candidates = nr_candidates;\r\n      min_candidates_square = square;\r\n    }\r\n  }\r\n\r\n  // Recursively search through each of the candidates of the square\r\n  // starting with the one with fewest candidates.\r\n\r\n  // Rotate through the candidates forwards\r\n  var min_candidates = candidates[min_candidates_square];\r\n  if (!reverse) {\r\n    for (var vi in min_candidates) {\r\n      var val = min_candidates[vi];\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      var candidates_copy = JSON.parse(JSON.stringify(candidates));\r\n      var candidates_next = sudoku._search(\r\n        sudoku._assign(candidates_copy, min_candidates_square, val)\r\n      );\r\n\r\n      if (candidates_next) {\r\n        return candidates_next;\r\n      }\r\n    }\r\n\r\n    // Rotate through the candidates backwards\r\n  } else {\r\n    for (vi = min_candidates.length - 1; vi >= 0; --vi) {\r\n      val = min_candidates[vi];\r\n\r\n      // TODO: Implement a non-rediculous deep copy function\r\n      candidates_copy = JSON.parse(JSON.stringify(candidates));\r\n      candidates_next = sudoku._search(\r\n        sudoku._assign(candidates_copy, min_candidates_square, val),\r\n        reverse\r\n      );\r\n\r\n      if (candidates_next) {\r\n        return candidates_next;\r\n      }\r\n    }\r\n  }\r\n\r\n  // If we get through all combinations of the square with the fewest\r\n  // candidates without finding an answer, there isn't one. Return false.\r\n  return false;\r\n};\r\n\r\nsudoku._assign = function (candidates, square, val) {\r\n  /* Eliminate all values, *except* for `val`, from `candidates` at\r\n  `square` (candidates[square]), and propagate. Return the candidates map\r\n  when finished. If a contradiciton is found, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */\r\n\r\n  // Grab a list of canidates without 'val'\r\n  var other_vals = candidates[square].replace(val, \"\");\r\n\r\n  // Loop through all other values and eliminate them from the candidates\r\n  // at the current square, and propigate. If at any point we get a\r\n  // contradiction, return false.\r\n  for (var ovi in other_vals) {\r\n    var other_val = other_vals[ovi];\r\n\r\n    var candidates_next =\r\n      sudoku._eliminate(candidates, square, other_val);\r\n\r\n    if (!candidates_next) {\r\n      //console.log(\"Contradiction found by _eliminate.\");\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return candidates;\r\n};\r\n\r\nsudoku._eliminate = function (candidates, square, val) {\r\n  /* Eliminate `val` from `candidates` at `square`, (candidates[square]),\r\n  and propagate when values or places <= 2. Return updated candidates,\r\n  unless a contradiction is detected, in which case, return false.\r\n\r\n  WARNING: This will modify the contents of `candidates` directly.\r\n  */\r\n\r\n  // If `val` has already been eliminated from candidates[square], return\r\n  // with candidates.\r\n  if (!sudoku._in(val, candidates[square])) {\r\n    return candidates;\r\n  }\r\n\r\n  // Remove `val` from candidates[square]\r\n  candidates[square] = candidates[square].replace(val, '');\r\n\r\n  // If the square has only candidate left, eliminate that value from its\r\n  // peers\r\n  var nr_candidates = candidates[square].length;\r\n  if (nr_candidates === 1) {\r\n    var target_val = candidates[square];\r\n\r\n    for (var pi in SQUARE_PEERS_MAP[square]) {\r\n      var peer = SQUARE_PEERS_MAP[square][pi];\r\n\r\n      var candidates_new =\r\n        sudoku._eliminate(candidates, peer, target_val);\r\n\r\n      if (!candidates_new) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Otherwise, if the square has no candidates, we have a contradiction.\r\n    // Return false.\r\n  } if (nr_candidates === 0) {\r\n    return false;\r\n  }\r\n\r\n  // If a unit is reduced to only one place for a value, then assign it\r\n  for (var ui in SQUARE_UNITS_MAP[square]) {\r\n    var unit = SQUARE_UNITS_MAP[square][ui];\r\n\r\n    var val_places = [];\r\n    for (var si in unit) {\r\n      var unit_square = unit[si];\r\n      if (sudoku._in(val, candidates[unit_square])) {\r\n        val_places.push(unit_square);\r\n      }\r\n    }\r\n\r\n    // If there's no place for this value, we have a contradition!\r\n    // return false\r\n    if (val_places.length === 0) {\r\n      return false;\r\n\r\n      // Otherwise the value can only be in one place. Assign it there.\r\n    } else if (val_places.length === 1) {\r\n      candidates_new =\r\n        sudoku._assign(candidates, val_places[0], val);\r\n\r\n      if (!candidates_new) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return candidates;\r\n};\r\n\r\n\r\n// Square relationships\r\n// -------------------------------------------------------------------------\r\n// Squares, and their relationships with values, units, and peers.\r\n\r\nsudoku._get_square_vals_map = function (board) {\r\n  /* Return a map of squares -> values\r\n  */\r\n  var squares_vals_map = {};\r\n\r\n  // Make sure `board` is a string of length 81\r\n  if (board.length !== SQUARES.length) {\r\n    // eslint-disable-next-line\r\n    throw \"Board/squares length mismatch.\";\r\n\r\n  } else {\r\n    for (var i in SQUARES) {\r\n      squares_vals_map[SQUARES[i]] = board[i];\r\n    }\r\n  }\r\n\r\n  return squares_vals_map;\r\n};\r\n\r\nsudoku._get_square_units_map = function (squares, units) {\r\n  /* Return a map of `squares` and their associated units (row, col, box)\r\n  */\r\n  var square_unit_map = {};\r\n\r\n  // For every square...\r\n  for (var si in squares) {\r\n    var cur_square = squares[si];\r\n\r\n    // Maintain a list of the current square's units\r\n    var cur_square_units = [];\r\n\r\n    // Look through the units, and see if the current square is in it,\r\n    // and if so, add it to the list of of the square's units.\r\n    for (var ui in units) {\r\n      var cur_unit = units[ui];\r\n\r\n      if (cur_unit.indexOf(cur_square) !== -1) {\r\n        cur_square_units.push(cur_unit);\r\n      }\r\n    }\r\n\r\n    // Save the current square and its units to the map\r\n    square_unit_map[cur_square] = cur_square_units;\r\n  }\r\n\r\n  return square_unit_map;\r\n};\r\n\r\nsudoku._get_square_peers_map = function (squares, units_map) {\r\n  /* Return a map of `squares` and their associated peers, i.e., a set of\r\n  other squares in the square's unit.\r\n  */\r\n  var square_peers_map = {};\r\n\r\n  // For every square...\r\n  for (var si in squares) {\r\n    var cur_square = squares[si];\r\n    var cur_square_units = units_map[cur_square];\r\n\r\n    // Maintain list of the current square's peers\r\n    var cur_square_peers = [];\r\n\r\n    // Look through the current square's units map...\r\n    for (var sui in cur_square_units) {\r\n      var cur_unit = cur_square_units[sui];\r\n\r\n      for (var ui in cur_unit) {\r\n        var cur_unit_square = cur_unit[ui];\r\n\r\n        if (cur_square_peers.indexOf(cur_unit_square) === -1 &&\r\n          cur_unit_square !== cur_square) {\r\n          cur_square_peers.push(cur_unit_square);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Save the current square an its associated peers to the map\r\n    square_peers_map[cur_square] = cur_square_peers;\r\n  }\r\n\r\n  return square_peers_map;\r\n};\r\n\r\nsudoku._get_all_units = function (rows, cols) {\r\n  /* Return a list of all units (rows, cols, boxes)\r\n  */\r\n  var units = [];\r\n\r\n  // Rows\r\n  for (var ri in rows) {\r\n    units.push(sudoku._cross(rows[ri], cols));\r\n  }\r\n\r\n  // Columns\r\n  for (var ci in cols) {\r\n    units.push(sudoku._cross(rows, cols[ci]));\r\n  }\r\n\r\n  // Boxes\r\n  var row_squares = [\"ABC\", \"DEF\", \"GHI\"];\r\n  var col_squares = [\"123\", \"456\", \"789\"];\r\n  for (var rsi in row_squares) {\r\n    for (var csi in col_squares) {\r\n      units.push(sudoku._cross(row_squares[rsi], col_squares[csi]));\r\n    }\r\n  }\r\n\r\n  return units;\r\n};\r\n\r\n\r\n// Conversions\r\n// -------------------------------------------------------------------------\r\nsudoku.board_string_to_grid = function (board_string) {\r\n  /* Convert a board string to a two-dimensional array\r\n  */\r\n  var rows = [];\r\n  var cur_row = [];\r\n  for (var i in board_string) {\r\n    cur_row.push(board_string[i]);\r\n    if (i % 9 === 8) {\r\n      rows.push(cur_row);\r\n      cur_row = [];\r\n    }\r\n  }\r\n  return rows;\r\n};\r\n\r\nsudoku.board_grid_to_string = function (board_grid) {\r\n  /* Convert a board grid to a string\r\n  */\r\n  var board_string = \"\";\r\n  for (var r = 0; r < 9; ++r) {\r\n    for (var c = 0; c < 9; ++c) {\r\n      board_string += board_grid[r][c];\r\n    }\r\n  }\r\n  return board_string;\r\n};\r\n\r\n\r\n// Utility\r\n// -------------------------------------------------------------------------\r\n\r\nsudoku.print_board = function (board) {\r\n  /* Print a sudoku `board` to the console.\r\n  */\r\n\r\n  // Assure a valid board\r\n  var report = sudoku.validate_board(board);\r\n  if (report !== true) {\r\n    throw report;\r\n  }\r\n\r\n  var V_PADDING = \" \";  // Insert after each square\r\n  var H_PADDING = '\\n'; // Insert after each row\r\n\r\n  var V_BOX_PADDING = \"  \"; // Box vertical padding\r\n  var H_BOX_PADDING = '\\n'; // Box horizontal padding\r\n\r\n  var display_string = \"\";\r\n\r\n  for (var i in board) {\r\n    var square = board[i];\r\n\r\n    // Add the square and some padding\r\n    display_string += square + V_PADDING;\r\n\r\n    // Vertical edge of a box, insert v. box padding\r\n    if (i % 3 === 2) {\r\n      display_string += V_BOX_PADDING;\r\n    }\r\n\r\n    // End of a line, insert horiz. padding\r\n    if (i % 9 === 8) {\r\n      display_string += H_PADDING;\r\n    }\r\n\r\n    // Horizontal edge of a box, insert h. box padding\r\n    if (i % 27 === 26) {\r\n      display_string += H_BOX_PADDING;\r\n    }\r\n  }\r\n\r\n  console.log(display_string);\r\n};\r\n\r\nsudoku.validate_board = function (board) {\r\n  /* Return if the given `board` is valid or not. If it's valid, return\r\n  true. If it's not, return a string of the reason why it's not.\r\n  */\r\n\r\n  // Check for empty board\r\n  if (!board) {\r\n    return \"Empty board\";\r\n  }\r\n\r\n  // Invalid board length\r\n  if (board.length !== NR_SQUARES) {\r\n    return \"Invalid board size. Board must be exactly \" + NR_SQUARES +\r\n      \" squares.\";\r\n  }\r\n\r\n  // Check for invalid characters\r\n  for (var i in board) {\r\n    if (!sudoku._in(board[i], sudoku.DIGITS) && board[i] !== sudoku.BLANK_CHAR) {\r\n      return \"Invalid board character encountered at index \" + i +\r\n        \": \" + board[i];\r\n    }\r\n  }\r\n\r\n  // Otherwise, we're good. Return true.\r\n  return true;\r\n};\r\n\r\nsudoku._cross = function (a, b) {\r\n  /* Cross product of all elements in `a` and `b`, e.g.,\r\n  sudoku._cross(\"abc\", \"123\") ->\r\n  [\"a1\", \"a2\", \"a3\", \"b1\", \"b2\", \"b3\", \"c1\", \"c2\", \"c3\"]\r\n  */\r\n  var result = [];\r\n  for (var ai in a) {\r\n    for (var bi in b) {\r\n      result.push(a[ai] + b[bi]);\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nsudoku._in = function (v, seq) {\r\n  /* Return if a value `v` is in sequence `seq`.\r\n  */\r\n  return seq.indexOf(v) !== -1;\r\n};\r\n\r\nsudoku._first_true = function (seq) {\r\n  /* Return the first element in `seq` that is true. If no element is\r\n  true, return false.\r\n  */\r\n  for (var i in seq) {\r\n    if (seq[i]) {\r\n      return seq[i];\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nsudoku._shuffle = function (seq) {\r\n  /* Return a shuffled version of `seq`\r\n  */\r\n\r\n  // Create an array of the same size as `seq` filled with false\r\n  var shuffled = [];\r\n  for (var i = 0; i < seq.length; ++i) {\r\n    shuffled.push(false);\r\n  }\r\n\r\n  for (i in seq) {\r\n    var ti = sudoku._rand_range(seq.length);\r\n\r\n    while (shuffled[ti]) {\r\n      ti = (ti + 1) > (seq.length - 1) ? 0 : (ti + 1);\r\n    }\r\n\r\n    shuffled[ti] = seq[i];\r\n  }\r\n\r\n  return shuffled;\r\n};\r\n\r\nsudoku._rand_range = function (max, min) {\r\n  /* Get a random integer in the range of `min` to `max` (non inclusive).\r\n  If `min` not defined, default to 0. If `max` not defined, throw an\r\n  error.\r\n  */\r\n  min = min || 0;\r\n  if (max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n  } else {\r\n    // eslint-disable-next-line\r\n    throw \"Range undefined\";\r\n  }\r\n};\r\n\r\nsudoku._strip_dups = function (seq) {\r\n  /* Strip duplicate values from `seq`\r\n  */\r\n  var seq_set = [];\r\n  var dup_map = {};\r\n  for (var i in seq) {\r\n    var e = seq[i];\r\n    if (!dup_map[e]) {\r\n      seq_set.push(e);\r\n      dup_map[e] = true;\r\n    }\r\n  }\r\n  return seq_set;\r\n};\r\n\r\nsudoku._force_range = function (nr, max, min) {\r\n  /* Force `nr` to be within the range from `min` to, but not including,\r\n  `max`. `min` is optional, and will default to 0. If `nr` is undefined,\r\n  treat it as zero.\r\n  */\r\n  min = min || 0\r\n  nr = nr || 0\r\n  if (nr < min) {\r\n    return min;\r\n  }\r\n  if (nr > max) {\r\n    return max;\r\n  }\r\n  return nr\r\n}\r\n\r\n// Initialize library after load\r\ninitialize();\r\n\r\nexport const getSudoku = () => {\r\n  return sudoku;\r\n}\r\n\r\n// Pass whatever the root object is, like 'window' in browsers\r\n//})(this);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}